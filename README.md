# Эмулятор протокола Token Ring

## Описание

Эмулятор протокола Token Ring на Go 1.24+ с использованием исключительно стандартной библиотеки. Реализует кольцевую топологию сети, где каждый узел представлен goroutine, а связь осуществляется через каналы Go.

## Условие задачи

Используя исключительно стандартную библиотеку написать на Go эмулятор протокола TokenRing:
- Аргументом командной строки задается число узлов
- Каждый узел — легковесный поток (goroutine)
- Узел i связан каналами с узлами i-1 и i+1
- При старте каждый узел получает порядковый номер как идентификатор
- Узлы передают Token (данные, SHA3 хэш получателя, TTL)
- Сообщение доставляется по совпадению хэша или отбрасывается по TTL
- Первое сообщение отправляет главный поток узлу 1
- Получивший сообщение генерирует новое для случайного получателя
- Вывод лога пересылки сообщений в консоль

## Аргументы запуска

```bash
go run main.go <число_узлов>
```

**Параметры:**
- `<число_узлов>` — количество узлов в кольце (целое число ≥ 2)

**Примеры:**
```bash
go run main.go 3    # Кольцо из 3 узлов
go run main.go 5    # Кольцо из 5 узлов  
go run main.go 10   # Кольцо из 10 узлов
```

## Структуры данных

### Token
```go
type Token struct {
    Data         string  // Данные сообщения
    ReceiverHash string  // SHA3-256 хэш ID получателя
    TTL          int     // Время жизни (счетчик пересылок)
    SenderID     int     // ID отправителя
}
```

### Node
```go
type Node struct {
    ID       int           // Уникальный номер узла (0, 1, 2, ...)
    Hash     string        // SHA3-256 хэш собственного ID
    Input    <-chan Token  // Канал для получения токенов
    Output   chan<- Token  // Канал для отправки токенов
    NumNodes int           // Общее количество узлов в кольце
    Stop     *bool         // Флаг остановки (общий для всех узлов)
    Mu       *sync.Mutex   // Мьютекс для синхронизации доступа к Stop
}
```

## Функции

### hashID(id int) string
Вычисляет SHA3-256 хэш от числового ID узла.
- Преобразует ID в строку
- Вычисляет SHA3-256 хэш
- Возвращает hex-представление хэша

### Node.Run(wg *sync.WaitGroup)
Основной цикл работы узла:
1. Читает токены из входного канала
2. Проверяет флаг остановки
3. Обрабатывает каждый полученный токен
4. Завершается при закрытии канала

### Node.processToken(token Token)
Обработка полученного токена:
1. **Проверка получателя**: Если `token.ReceiverHash == n.Hash` → токен предназначен этому узлу
2. **Проверка TTL**: Если `token.TTL <= 0` → токен "умер"
3. **Пересылка**: Иначе уменьшает TTL и отправляет дальше

### Node.sendNewMessage()
Генерация и отправка нового сообщения:
1. Выбирает случайного получателя (кроме себя)
2. Генерирует случайное сообщение
3. Создает новый токен с TTL = количество_узлов + 2
4. Отправляет токен в выходной канал

## Архитектура кольца

```
Узел 0 ←------ Узел N-1
  ↓              ↑
Узел 1          ...
  ↓              ↑  
Узел 2 ------→ Узел 3
```

### Связи каналов
- Узел `i` получает от узла `(i-1+N) % N`
- Узел `i` отправляет в узел `i`
- Канал `channels[i]` ведет от узла `i` к узлу `(i+1) % N`

## Алгоритм работы

### Инициализация
1. Создается массив каналов `channels[0..N-1]`
2. Создается массив узлов `nodes[0..N-1]`
3. Каждый узел получает:
   - Уникальный ID
   - SHA3-хэш своего ID
   - Входной канал от предыдущего узла
   - Выходной канал к следующему узлу

### Запуск
1. Все узлы запускаются как goroutines
2. Главный поток отправляет первый токен узлу 1
3. Узлы начинают обмен сообщениями

### Маршрутизация
1. Узел получает токен
2. Сравнивает `token.ReceiverHash` со своим хэшем
3. Если совпадает → принимает сообщение
4. Если не совпадает → проверяет TTL и пересылает

### Завершение
1. Устанавливается флаг `stop = true`
2. Закрываются все каналы
3. Ожидается завершение всех goroutines через `sync.WaitGroup`

## Синхронизация

### Проблемы race condition
- Флаг `stop` защищен мьютексом `mu`
- Все узлы используют один общий флаг и мьютекс
- Проверка флага происходит перед отправкой сообщений

### Graceful shutdown
- Сначала устанавливается флаг остановки
- Затем закрываются каналы
- Узлы завершаются при чтении из закрытого канала
- `sync.WaitGroup` ожидает завершения всех goroutines

## Особенности реализации

### TTL (Time To Live)
- Начальное значение: `количество_узлов + 2`
- Уменьшается на 1 при каждой пересылке
- При TTL = 0 сообщение удаляется

### Буферизация каналов
- Каналы имеют буфер размером 1
- Предотвращает блокировку при отправке
- Позволяет узлам работать асинхронно

### Случайность
- Получатель выбирается случайно (кроме отправителя)
- Сообщения генерируются из предопределенного списка
- Используется `rand.Seed(time.Now().UnixNano())`

## Логирование

Выводятся события:
- `ПОЛУЧЕНО` — узел получил предназначенное ему сообщение
- `Пересылка` — узел пересылает сообщение дальше
- `TTL истёк` — сообщение удалено из-за истечения времени жизни
- `ОТПРАВКА` — узел генерирует новое сообщение

## Демонстрация работы

### Запуск с 3 узлами

```bash
$ go run main.go 3
Token Ring: 3 узлов

[Главный] ОТПРАВКА узлу 1: Стартовое сообщение
[Узел 0] Пересылка (TTL=4): Стартовое сообщение
[Узел 1] ПОЛУЧЕНО от -1: Стартовое сообщение
[Узел 1] ОТПРАВКА узлу 2: сообщение 1 (TTL=5)
[Узел 2] ПОЛУЧЕНО от 1: сообщение 1
[Узел 2] ОТПРАВКА узлу 0: сообщение 3 (TTL=5)
[Узел 0] ПОЛУЧЕНО от 2: сообщение 3
[Узел 0] ОТПРАВКА узлу 1: сообщение 2 (TTL=5)
[Узел 1] ПОЛУЧЕНО от 0: сообщение 2
```

### Запуск с 5 узлами

```bash
$ go run main.go 5
Token Ring: 5 узлов

[Главный] ОТПРАВКА узлу 1: Стартовое сообщение
[Узел 0] Пересылка (TTL=6): Стартовое сообщение
[Узел 1] ПОЛУЧЕНО от -1: Стартовое сообщение
[Узел 1] ОТПРАВКА узлу 4: сообщение 6 (TTL=7)
[Узел 2] Пересылка (TTL=6): сообщение 6
[Узел 3] Пересылка (TTL=5): сообщение 6
[Узел 4] ПОЛУЧЕНО от 1: сообщение 6
[Узел 4] ОТПРАВКА узлу 2: сообщение 1 (TTL=7)
[Узел 0] Пересылка (TTL=6): сообщение 1
[Узел 1] Пересылка (TTL=5): сообщение 1
[Узел 2] ПОЛУЧЕНО от 4: сообщение 1
```

### Демонстрация истечения TTL

```bash
$ go run main.go 4
[Узел 2] ОТПРАВКА узлу 0: сообщение 4 (TTL=6)
[Узел 3] Пересылка (TTL=5): сообщение 4
[Узел 0] ПОЛУЧЕНО от 2: сообщение 4
[Узел 1] ОТПРАВКА узлу 3: сообщение 2 (TTL=6)
[Узел 2] Пересылка (TTL=5): сообщение 2
[Узел 3] ПОЛУЧЕНО от 1: сообщение 2
```

## Требования

- **Go версии 1.24+** (для поддержки `crypto/sha3` в стандартной библиотеке)
- Операционная система: Windows/Linux/macOS

## Установка Go 1.24

```bash
# Установка Go 1.24
go install golang.org/dl/go1.24.0@latest
go1.24.0 download

# Запуск эмулятора
go1.24.0 run main.go 5
```#   P L _ 3  
 